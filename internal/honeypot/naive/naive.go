package naive

import (
	_ "embed"
	"log/slog"
	"math/rand/v2"
	"net/http"
	"time"

	"github.com/TecharoHQ/anubis/internal/honeypot"
	"github.com/TecharoHQ/anubis/lib/store"
	"github.com/a-h/templ"
	"github.com/google/uuid"
	"github.com/m1/gospin"
)

//go:generate go tool github.com/a-h/templ/cmd/templ generate

// XXX(Xe): All of this was generated by ChatGPT, GLM 4.6, and GPT-OSS 120b. This is pseudoprofound bullshit in spintax[1] format so that the bullshit generator can emit plausibly human-authored text while being very computationally cheap.
//
// It feels somewhat poetic to use spammer technology in Anubis.
//
// [1]: https://outboundly.ai/blogs/what-is-spintax-and-how-to-use-it/
//
//go:embed spintext.txt
var spintext string

//go:embed titles.txt
var titles string

//go:embed affirmations.txt
var affirmations string

func New(st store.Interface, lg *slog.Logger) *Impl {
	spin := gospin.New(nil)

	return &Impl{
		st:    st,
		infos: store.JSON[honeypot.Info]{Underlying: st, Prefix: "honeypot-infos"},
		spin:  spin,
		lg:    lg.With("component", "honeypot/naive"),
	}
}

type Impl struct {
	st    store.Interface
	infos store.JSON[honeypot.Info]
	spin  *gospin.Spinner
	lg    *slog.Logger
}

func (i *Impl) makeAffirmations() []string {
	result, err := i.spin.SpinN(affirmations, rand.IntN(5)+1)
	if err != nil {
		i.lg.Debug("can't spin affirmations, using fallback", "err", err)
		return []string{uuid.NewString()}
	}

	return result
}

func (i *Impl) makeSpins() []string {
	result, err := i.spin.SpinN(spintext, rand.IntN(8)+8)
	if err != nil {
		i.lg.Debug("can't spin text, using fallback", "err", err)
		return []string{uuid.NewString()}
	}

	return result
}

func (i *Impl) makeTitle() string {
	result, err := i.spin.Spin(titles)
	if err != nil {
		i.lg.Debug("can't spin titles, using fallback", "err", err)
		return uuid.NewString()
	}

	return result
}

func (i *Impl) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	t0 := time.Now()

	id := r.PathValue("id")
	if id == "" {
		id = uuid.NewString()
	}

	stage := r.PathValue("stage")
	if stage == "init" {
		i.lg.Debug("found new entrance point", "id", id, "userAgent", r.UserAgent(), "ip", r.Header.Get("X-Real-Ip"))
	}

	spins := i.makeSpins()
	affirmations := i.makeAffirmations()
	title := i.makeTitle()

	var links []link
	for _, affirmation := range affirmations {
		links = append(links, link{
			href: uuid.NewString(),
			body: affirmation,
		})
	}

	templ.Handler(
		base(title, i.maze(spins, links)),
		templ.WithStreaming(),
		templ.WithStatus(http.StatusOK),
	).ServeHTTP(w, r)

	t1 := time.Since(t0)
	honeypot.Timings.WithLabelValues("naive").Observe(float64(t1.Milliseconds()))
}

type link struct {
	href string
	body string
}
